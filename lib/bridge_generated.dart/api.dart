// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`

/// Nostrクライアントを初期化（hex公開鍵を返す）
Future<String> initNostrClient({required String secretKeyHex, required List<String> relays}) =>
    RustLib.instance.api.crateApiInitNostrClient(secretKeyHex: secretKeyHex, relays: relays);

/// 公開鍵をnpub形式で取得
Future<String> getPublicKeyNpub() => RustLib.instance.api.crateApiGetPublicKeyNpub();

/// 新しい秘密鍵を生成（hex形式）
Future<String> generateSecretKey() => RustLib.instance.api.crateApiGenerateSecretKey();

Future<KeyPair> generateKeypair() => RustLib.instance.api.crateApiGenerateKeypair();

/// Todoを作成
Future<String> createTodo({required TodoData todo}) => RustLib.instance.api.crateApiCreateTodo(todo: todo);

/// Todoを更新
Future<String> updateTodo({required TodoData todo}) => RustLib.instance.api.crateApiUpdateTodo(todo: todo);

/// Todoを削除
Future<void> deleteTodo({required String todoId}) => RustLib.instance.api.crateApiDeleteTodo(todoId: todoId);

/// 全Todoを同期（Kind 30001 - 新実装）
Future<List<TodoData>> syncTodoList() => RustLib.instance.api.crateApiSyncTodoList();

/// Todoリストを作成（Kind 30001）
Future<String> createTodoList({required List<TodoData> todos}) =>
    RustLib.instance.api.crateApiCreateTodoList(todos: todos);

/// 全Todoを同期（旧実装 - Kind 30078）
Future<List<TodoData>> syncTodos() => RustLib.instance.api.crateApiSyncTodos();

/// 秘密鍵を暗号化して保存（パスワードベース）
Future<void> saveEncryptedSecretKey({
  required String storagePath,
  required String secretKey,
  required String password,
}) => RustLib.instance.api.crateApiSaveEncryptedSecretKey(
  storagePath: storagePath,
  secretKey: secretKey,
  password: password,
);

/// 暗号化された秘密鍵を読み込み
Future<String> loadEncryptedSecretKey({required String storagePath, required String password}) =>
    RustLib.instance.api.crateApiLoadEncryptedSecretKey(storagePath: storagePath, password: password);

/// 公開鍵を保存（Amber使用時）
Future<void> savePublicKey({required String storagePath, required String publicKey}) =>
    RustLib.instance.api.crateApiSavePublicKey(storagePath: storagePath, publicKey: publicKey);

/// 公開鍵を読み込み
Future<String?> loadPublicKey({required String storagePath}) =>
    RustLib.instance.api.crateApiLoadPublicKey(storagePath: storagePath);

/// 保存された鍵を削除
Future<void> deleteStoredKeys({required String storagePath}) =>
    RustLib.instance.api.crateApiDeleteStoredKeys(storagePath: storagePath);

/// 暗号化された秘密鍵が存在するか確認
Future<bool> hasEncryptedKey({required String storagePath}) =>
    RustLib.instance.api.crateApiHasEncryptedKey(storagePath: storagePath);

/// 公開鍵が存在するか確認
Future<bool> hasPublicKey({required String storagePath}) =>
    RustLib.instance.api.crateApiHasPublicKey(storagePath: storagePath);

/// Amberから受け取った署名済みイベントを検証
Future<bool> verifyAmberSignature({required String eventJson}) =>
    RustLib.instance.api.crateApiVerifyAmberSignature(eventJson: eventJson);

/// 公開鍵のみでNostrクライアントを初期化（Amber使用時）
/// 署名が必要な操作はAmber経由で行う
Future<String> initNostrClientWithPubkey({required String publicKeyHex, required List<String> relays}) =>
    RustLib.instance.api.crateApiInitNostrClientWithPubkey(publicKeyHex: publicKeyHex, relays: relays);

/// 未署名Todoイベントを作成（Amber署名用）
/// Amberに送信するイベントJSON文字列を返す
Future<String> createUnsignedTodoEvent({required TodoData todo, required String publicKeyHex}) =>
    RustLib.instance.api.crateApiCreateUnsignedTodoEvent(todo: todo, publicKeyHex: publicKeyHex);

/// 署名済みイベントをリレーに送信
Future<String> sendSignedEvent({required String eventJson}) =>
    RustLib.instance.api.crateApiSendSignedEvent(eventJson: eventJson);

/// 暗号化済みcontentで未署名Todoリストイベントを作成（Kind 30001 - Amber暗号化済み用）
Future<String> createUnsignedEncryptedTodoListEvent({required String encryptedContent, required String publicKeyHex}) =>
    RustLib.instance.api.crateApiCreateUnsignedEncryptedTodoListEvent(
      encryptedContent: encryptedContent,
      publicKeyHex: publicKeyHex,
    );

/// 暗号化済みcontentで未署名Todoイベントを作成（Amber暗号化済み用 - 旧実装）
Future<String> createUnsignedEncryptedTodoEvent({
  required String todoId,
  required String encryptedContent,
  required String publicKeyHex,
}) => RustLib.instance.api.crateApiCreateUnsignedEncryptedTodoEvent(
  todoId: todoId,
  encryptedContent: encryptedContent,
  publicKeyHex: publicKeyHex,
);

Future<EncryptedTodoListEvent?> fetchEncryptedTodoListForPubkey({required String publicKeyHex}) =>
    RustLib.instance.api.crateApiFetchEncryptedTodoListForPubkey(publicKeyHex: publicKeyHex);

Future<List<EncryptedTodoEvent>> fetchEncryptedTodosForPubkey({required String publicKeyHex}) =>
    RustLib.instance.api.crateApiFetchEncryptedTodosForPubkey(publicKeyHex: publicKeyHex);

/// npub形式の公開鍵をhex形式に変換
Future<String> npubToHex({required String npub}) => RustLib.instance.api.crateApiNpubToHex(npub: npub);

/// hex形式の公開鍵をnpub形式に変換
Future<String> hexToNpub({required String hex}) => RustLib.instance.api.crateApiHexToNpub(hex: hex);

/// 指定したイベントIDのリストを削除（Kind 5削除イベントを送信）
Future<String> deleteEvents({required List<String> eventIds, String? reason}) =>
    RustLib.instance.api.crateApiDeleteEvents(eventIds: eventIds, reason: reason);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MeisoNostrClient>>
abstract class MeisoNostrClient implements RustOpaqueInterface {
  /// TodoをNostrイベントとして作成（旧実装 - 後方互換性のため残す）
  Future<String> createTodo({required TodoData todo});

  /// TodoリストをNostrイベントとして作成（Kind 30001 - NIP-51 Bookmark List）
  /// 全TODOを1つのイベントとして管理
  Future<String> createTodoList({required List<TodoData> todos});

  /// Todoを削除（削除イベント送信）
  Future<void> deleteTodo({required String todoId});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// 新しいクライアントを作成（秘密鍵から）
  static Future<MeisoNostrClient> newInstance({required String secretKeyHex, required List<String> relays}) =>
      RustLib.instance.api.crateApiMeisoNostrClientNew(secretKeyHex: secretKeyHex, relays: relays);

  /// 公開鍵を取得（hex形式）
  Future<String> publicKeyHex();

  /// 公開鍵を取得（npub形式）
  Future<String> publicKeyNpub();

  /// TodoリストをNostrから同期（Kind 30001）
  Future<List<TodoData>> syncTodoList();

  /// 全てのTodoを同期（リレーから取得）- 旧実装（Kind 30078）
  Future<List<TodoData>> syncTodos();

  /// Todoを更新（既存イベントを置き換え）
  Future<String> updateTodo({required TodoData todo});
}

/// 公開鍵だけで暗号化されたTodoイベントを取得（Amber復号化用 - 旧実装 Kind 30078）
/// 復号化はAmber側で行うため、暗号化されたままのイベントを返す
class EncryptedTodoEvent {
  final String eventId;
  final String encryptedContent;
  final PlatformInt64 createdAt;
  final String dTag;

  const EncryptedTodoEvent({
    required this.eventId,
    required this.encryptedContent,
    required this.createdAt,
    required this.dTag,
  });

  @override
  int get hashCode => eventId.hashCode ^ encryptedContent.hashCode ^ createdAt.hashCode ^ dTag.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EncryptedTodoEvent &&
          runtimeType == other.runtimeType &&
          eventId == other.eventId &&
          encryptedContent == other.encryptedContent &&
          createdAt == other.createdAt &&
          dTag == other.dTag;
}

/// 暗号化されたTodoリストイベントを取得（Amber復号化用 - Kind 30001）
class EncryptedTodoListEvent {
  final String eventId;
  final String encryptedContent;
  final PlatformInt64 createdAt;

  const EncryptedTodoListEvent({required this.eventId, required this.encryptedContent, required this.createdAt});

  @override
  int get hashCode => eventId.hashCode ^ encryptedContent.hashCode ^ createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EncryptedTodoListEvent &&
          runtimeType == other.runtimeType &&
          eventId == other.eventId &&
          encryptedContent == other.encryptedContent &&
          createdAt == other.createdAt;
}

/// 鍵ペアを生成（nsec/npub形式で返す）
class KeyPair {
  final String privateKeyNsec;
  final String publicKeyNpub;
  final String privateKeyHex;
  final String publicKeyHex;

  const KeyPair({
    required this.privateKeyNsec,
    required this.publicKeyNpub,
    required this.privateKeyHex,
    required this.publicKeyHex,
  });

  @override
  int get hashCode => privateKeyNsec.hashCode ^ publicKeyNpub.hashCode ^ privateKeyHex.hashCode ^ publicKeyHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPair &&
          runtimeType == other.runtimeType &&
          privateKeyNsec == other.privateKeyNsec &&
          publicKeyNpub == other.publicKeyNpub &&
          privateKeyHex == other.privateKeyHex &&
          publicKeyHex == other.publicKeyHex;
}

/// Todoデータ構造（Flutter側と同期）
class TodoData {
  final String id;
  final String title;
  final bool completed;
  final String? date;
  final int order;
  final String createdAt;
  final String updatedAt;
  final String? eventId;

  const TodoData({
    required this.id,
    required this.title,
    required this.completed,
    this.date,
    required this.order,
    required this.createdAt,
    required this.updatedAt,
    this.eventId,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      title.hashCode ^
      completed.hashCode ^
      date.hashCode ^
      order.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      eventId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TodoData &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          title == other.title &&
          completed == other.completed &&
          date == other.date &&
          order == other.order &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          eventId == other.eventId;
}
