# Meiso（Flutter + Rust）プロジェクト固有のルール

## 1. Riverpod状態管理の原則

### AsyncValue状態遷移の理解
- `AsyncLoading` → `AsyncData` → `AsyncLoading` → `AsyncData` の遷移を常に意識
- 初期化（`_initialize()`）と同期（`syncFromNostr()`）の非同期競合を理解
- `state is AsyncData` チェックと適切なフォールバック（ローカルストレージ）

### UI更新の保証
- `needsStateUpdate` フラグパターンを使う
- `AsyncLoading` から読み込んだ場合は必ず `state` を更新
- `ref.watch()` が `state` の変更を検知して `build()` を再実行することを理解
- `state` の二重更新は機能的には問題ない（パフォーマンスの無駄はあるが）

### Provider設計
- UIは極力 `StatelessWidget` で実装
- `Consumer(builder: ...)` を使い、`ConsumerWidget` は使用禁止
- 状態はすべて Provider 側で管理
- ビジネスロジックをUIに書かない

## 2. Flutter/Rust Bridge

### Rust側の責任
- 暗号化・復号化はすべてRust側
- Nostrプロトコルの実装はRust側
- エラーは `anyhow::Result` で返す
- `println!` デバッグログは最小限に

### Flutter側の責任
- UI/UXの実装
- Rust APIの呼び出しとエラーハンドリング
- ローカルストレージ（Hive）の管理
- Providerによる状態管理

### ブリッジの原則
- FFI呼び出しは常に `try-catch` で囲む
- Rust側のエラーを適切にFlutter側で処理
- `AppLogger` でログを統一
- 型変換は明示的に行う

## 3. Amber Mode対応

### Amberモードの特性
- 秘密鍵はFlutter側に保存しない
- すべての署名・暗号化・復号化はAmberに委譲
- タイムアウト処理を必ず実装（2分）
- `EventChannel` と `MethodChannel` を併用

### Amberモードのデバッグ
- Amberユーザーは最優先ターゲット
- Amberモードで動かない機能は致命的
- 秘密鍵モードとAmberモードの両方でテスト
- Amber特有のエラーハンドリングを実装

## 4. Nostr実装の原則

### NIP準拠
- Kind 30001（Bookmark Lists）はNIP-51準拠
- NIP-44暗号化を使用
- `d` タグで決定的なIDを生成（名前ベース）
- `title` タグでリスト名を保存

### リレー同期
- タイムアウトは10秒
- 同期失敗時はローカルデータを保持
- ネットワークエラー時もアプリは使用可能に
- 楽観的UI更新（同期前にUIを更新）

### データ整合性
- ローカルとリモートの両方にデータを保存
- リモート優先だが、ローカルをフォールバックに
- 名前ベースの決定的IDで重複を防止
- 削除時はローカルとリモートの両方から削除

## 5. カスタムリスト管理の特性

### 名前ベースID生成
- `CustomListHelpers.generateIdFromName()` を使用
- 同じ名前 → 同じID → 重複防止
- 大文字小文字は区別しない（正規化）

### 同期ロジック
- `syncListsFromNostr()` は空のリストでも呼び出す
- `createDefaultListsIfEmpty()` は同期後に実行
- デフォルトリスト：BRAIN DUMP, GROCERY, WISHLIST, NOSTR, WORK

### グループリスト
- `isGroup` フラグで個人リストと区別
- `groupMembers` に公開鍵リストを保存
- NIP-44で各メンバー用にAES鍵を暗号化
- メンバー削除時は再暗号化（Forward Secrecy）

## 6. デバッグとログ

### ログレベル
- `AppLogger.debug()`: 詳細な実行フロー
- `AppLogger.info()`: 重要な処理の開始・完了
- `AppLogger.warning()`: 想定外だが継続可能
- `AppLogger.error()`: エラー（`error:`, `stackTrace:` を使用）

### ログの原則
- 過剰なログを追加しない
- デバッグ用ログはコミット前に削除を検討
- Rust側の `println!` は最小限に
- ログだけの変更でコミットしない

## 7. テスト戦略

### テスト必須シナリオ
1. 既存データがある状態でのAmberログイン
2. 初回起動（データなし）
3. デバイス間の同期
4. タイミングのストレステスト
5. ネットワークエラー時の挙動

### テスト前の確認
- 理論的正しさを証明済みか？
- 実行フローを完全に理解しているか？
- 潜在的な競合を分析したか？
- 「テストしてください」と丸投げしていないか？

## 8. コミットメッセージ

### フォーマット

fix: 簡潔なタイトル
Root Cause:
問題の根本原因
Problem:
具体的な問題の説明
Solution:
解決方法の説明
Changes:
変更点1
変更点2
Impact:
この変更が与える影響
### コミットの粒度- 1コミット = 1つの問題解決- 無関係な変更を混ぜない- デバッグログのみの変更はコミットしない- 動作確認後にコミット## 9. 問題発生時の対応フロー1. **深呼吸する**   - 焦らない   - 落ち着いて問題を見る2. **問題の本質を理解する**   - 症状と原因を区別   - Oracleの指摘を正確に理解3. **実行フローを図示する**   - 非同期処理の順序   - 競合シナリオ   - 状態遷移4. **理論的に証明する**   - コードレビューベースで正しさを証明   - すべてのケースを検討   - ログは最後の確認5. **悪化したらロールバック**   - `git reset --hard`   - ゼロから見直す6. **自己評価してから報告**   - 5つの質問に答える   - 理論的正しさを説明   - 不確実な要素を明示## 10. このプロジェクトの哲学### シンプルさ- 複雑な実装より、シンプルで読みやすいコード- 過度な抽象化をしない- 必要になってから拡張する### プライバシー- ユーザーデータは完全に暗号化- 秘密鍵はRust側でArgon2id + AES-256-GCM- Amber統合でさらに安全に### UX最優先- UIが更新されなければ意味がない- ローディングが永遠に続くのは最悪- ネットワークエラーでもアプリは使える- 楽観的UI更新で体感速度を向上
